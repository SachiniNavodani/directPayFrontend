"use strict";
var tslint = require("tslint");
var path = require("path");
var codeFixActions = Object.create(null);
var registeredCodeFixes = false;
function computeKey(start, end) {
    return "[" + start + "," + end + "]";
}
var configFile = null;
var configuration = null;
var isTsLint4 = true;
var configCache = {
    filePath: null,
    configuration: null,
    isDefaultConfig: false,
    configFilePath: null
};
var linter = null;
var linterConfiguration = null;
var value = tslint;
linter = value.Linter;
linterConfiguration = value.Configuration;
if (!isTsLint4) {
    //linter = value;
}
/*function isTsLintVersion4(linter) {
    let version = '1.0.0';
    try {
        version = linter.VERSION;
    } catch (e) {
    }
    return semver.satisfies(version, ">= 4.0.0 || >= 4.0.0-dev");
}*/
//TODO we "steal"" an error code with a registered code fix. 2515 = implement inherited abstract class
var TSLINT_ERROR_CODE = 2515;
function init(modules) {
    var ts = modules.typescript;
    // By waiting for that TypeScript provides an API to register CodeFix
    // we define a registerCodeFix which uses the existing ts.codefix namespace.
    function registerCodeFix(action) {
        return ts.codefix.registerCodeFix(action);
    }
    if (!registeredCodeFixes && ts && ts.codefix) {
        registerCodeFixes(registerCodeFix);
        registeredCodeFixes = true;
    }
    function registerCodeFixes(registerCodeFix) {
        // Code fix for tslint fixes
        registerCodeFix({
            errorCodes: [TSLINT_ERROR_CODE],
            getCodeActions: function (context) {
                return null;
            }
        });
    }
    function create(info) {
        info.project.projectService.logger.info("tslint-language-service loaded");
        // Set up decorator
        var proxy = Object.create(null);
        var oldLS = info.languageService;
        var _loop_1 = function (k) {
            proxy[k] = function () {
                return oldLS[k].apply(oldLS, arguments);
            };
        };
        for (var k in oldLS) {
            _loop_1(k);
        }
        function makeDiagnostic(problem, file) {
            var message = (problem.getRuleName() !== null)
                ? problem.getFailure() + " (" + problem.getRuleName() + ")"
                : "" + problem.getFailure();
            // tslint5 supports to assign severities to rules
            var category;
            if (problem.getRuleSeverity && problem.getRuleSeverity() === 'error') {
                category = ts.DiagnosticCategory.Error;
            }
            else {
                category = ts.DiagnosticCategory.Warning;
            }
            var diagnostic = {
                file: file,
                start: problem.getStartPosition().getPosition(),
                length: problem.getEndPosition().getPosition() - problem.getStartPosition().getPosition(),
                messageText: message,
                category: category,
                source: 'tslint',
                code: TSLINT_ERROR_CODE
            };
            return diagnostic;
        }
        /**
         * Filter failures for the given document
         */
        function filterProblemsForDocument(documentPath, failures) {
            var normalizedPath = path.normalize(documentPath);
            // we only show diagnostics targetting this open document, some tslint rule return diagnostics for other documents/files
            var normalizedFiles = {};
            return failures.filter(function (each) {
                var fileName = each.getFileName();
                if (!normalizedFiles[fileName]) {
                    normalizedFiles[fileName] = path.normalize(fileName);
                }
                return normalizedFiles[fileName] === normalizedPath;
            });
        }
        function replacementsAreEmpty(fix) {
            // in tslint 4 a Fix has a replacement property witht the Replacements
            if (fix.replacements) {
                return fix.replacements.length === 0;
            }
            // tslint 5
            if (Array.isArray(fix)) {
                return fix.length === 0;
            }
            return false;
        }
        function recordCodeAction(problem, file) {
            var fix = null;
            // tslint can return a fix with an empty replacements array, these fixes are ignored
            if (problem.getFix && problem.getFix() && !replacementsAreEmpty(problem.getFix())) {
                fix = problem.getFix(); // createAutoFix(problem, document, problem.getFix());
            }
            if (!fix) {
                return;
            }
            var documentAutoFixes = codeFixActions[file.fileName];
            if (!documentAutoFixes) {
                documentAutoFixes = Object.create(null);
                codeFixActions[file.fileName] = documentAutoFixes;
            }
            documentAutoFixes[computeKey(problem.getStartPosition().getPosition(), problem.getEndPosition().getPosition())] = problem;
        }
        proxy.getSemanticDiagnostics = function (fileName) {
            var prior = oldLS.getSemanticDiagnostics(fileName);
            if (prior === undefined) {
                prior = [];
            }
            try {
                info.project.projectService.logger.info("Computing tslint semantic diagnostics...");
                delete codeFixActions[fileName];
                try {
                    configuration = getConfiguration(fileName, configFile);
                }
                catch (err) {
                    // this should not happen since we guard against incorrect configurations
                    // showConfigurationFailure(conn, err);
                    return prior;
                }
                var result = void 0;
                try {
                    if (isTsLint4) {
                        // TODO the types of the Program provided by tsserver libary are not compatible with the one provided by typescript
                        // casting away the type
                        var options = { fix: false };
                        var tslint_1 = new linter(options, oldLS.getProgram());
                        tslint_1.lint(fileName, "", configuration);
                        result = tslint_1.getResult();
                    }
                    // support for linting js files is only available in tslint > 4.0
                    /*else if (!isJsDocument(document)) {
                        (<any>options).configuration = configuration;
                        let tslint = new (<any>linter)(fsPath, contents, options);
                        result = tslint.lint();
                    } else {
                        return diagnostics;
                    }*/
                }
                catch (err) {
                    var errorMessage = "unknown error";
                    if (typeof err.message === 'string' || err.message instanceof String) {
                        errorMessage = err.message;
                    }
                    info.project.projectService.logger.info('tslint error ' + errorMessage);
                    return prior;
                }
                if (result.failures.length > 0) {
                    var tslintProblems = filterProblemsForDocument(fileName, result.failures);
                    if (tslintProblems && tslintProblems.length) {
                        var file_1 = oldLS.getProgram().getSourceFile(fileName);
                        prior.push.apply(prior, tslintProblems.map(function (d) { return makeDiagnostic(d, file_1); }));
                        tslintProblems.forEach(function (problem) {
                            recordCodeAction(problem, file_1);
                        });
                    }
                }
            }
            catch (e) {
                info.project.projectService.logger.info("tslint-language service error: " + e.toString());
                info.project.projectService.logger.info("Stack trace: " + e.stack);
            }
            return prior;
        };
        proxy.getCodeFixesAtPosition = function (fileName, start, end, errorCodes, formatOptions) {
            var prior = oldLS.getCodeFixesAtPosition(fileName, start, end, errorCodes, formatOptions);
            if (prior === undefined) {
                prior = [];
            }
            info.project.projectService.logger.info("tslint-language-service getCodeFixes " + errorCodes[0]);
            var documentFixes = codeFixActions[fileName];
            if (documentFixes) {
                var problem = documentFixes[computeKey(start, end)];
                if (problem) {
                    var fix = problem.getFix();
                    var replacements = null;
                    // in tslint4 a Fix has a replacement property with the Replacements
                    if (fix.replacements) {
                        // tslint4
                        replacements = fix.replacements;
                    }
                    else {
                        // in tslint 5 a Fix is a Replacement | Replacement[]                  
                        if (!Array.isArray(fix)) {
                            replacements = [fix];
                        }
                        else {
                            replacements = fix;
                        }
                    }
                    // Add tslint replacements codefix
                    var textChanges = replacements.map(function (each) { return convertReplacementToTextChange(each); });
                    prior.push({
                        description: "Fix '" + problem.getRuleName() + "'",
                        changes: [{
                                fileName: fileName,
                                textChanges: textChanges
                            }]
                    });
                    var file = oldLS.getProgram().getSourceFile(fileName);
                    // Add disable tslint rule codefix
                    prior.push({
                        description: "Disable rule '" + problem.getRuleName() + "'",
                        changes: [{
                                fileName: fileName,
                                textChanges: [{
                                        newText: "// tslint:disable-next-line:" + problem.getRuleName() + "\n",
                                        span: { start: file.getLineStarts()[problem.getStartPosition().getLineAndCharacter().line], length: 0 }
                                    }
                                ]
                            }]
                    });
                }
            }
            // Add "Go to rule definition" tslint.json codefix
            /* Comment this codefix, because it doesn't work with VSCode because textChanges is empty.
               Hope one day https://github.com/angelozerr/tslint-language-service/issues/4 will be supported.
                 
               if (configCache && configCache.configFilePath) {
                prior.push({
                    description: `Open tslint.json`,
                    changes: [{
                        fileName: configCache.configFilePath,
                        textChanges: []
                    }]
                });
            }*/
            return prior;
        };
        return proxy;
    }
    return { create: create };
}
function getConfiguration(filePath, configFileName) {
    if (configCache.configuration && configCache.filePath === filePath) {
        return configCache.configuration;
    }
    var isDefaultConfig = false;
    var configuration;
    var configFilePath = null;
    if (isTsLint4) {
        if (linterConfiguration.findConfigurationPath) {
            isDefaultConfig = linterConfiguration.findConfigurationPath(configFileName, filePath) === undefined;
        }
        var configurationResult = linterConfiguration.findConfiguration(configFileName, filePath);
        // between tslint 4.0.1 and tslint 4.0.2 the attribute 'error' has been removed from IConfigurationLoadResult
        // in 4.0.2 findConfiguration throws an exception as in version ^3.0.0
        if (configurationResult.error) {
            throw configurationResult.error;
        }
        configuration = configurationResult.results;
        configFilePath = configurationResult.path;
    }
    else {
        // prior to tslint 4.0 the findconfiguration functions where attached to the linter function
        if (linter.findConfigurationPath) {
            isDefaultConfig = linter.findConfigurationPath(configFileName, filePath) === undefined;
        }
        configuration = linter.findConfiguration(configFileName, filePath);
        configFilePath = configuration.path;
    }
    configCache = {
        filePath: filePath,
        isDefaultConfig: isDefaultConfig,
        configuration: configuration,
        configFilePath: configFilePath
    };
    return configCache.configuration;
}
function convertReplacementToTextChange(repl) {
    return {
        newText: repl.text,
        span: { start: repl.start, length: repl.length }
    };
}
module.exports = init;
//# sourceMappingURL=index.js.map